# 分金币 （Spreading the Wealth）
###  UVa上提交还没过，不知道为什么，但是算法绝逼是对的(在uDebug上搞了很多组复杂数据测试都是对的)。
## 描述
圆桌旁坐着n个人，每人有一定数量的金币，金币总数能被n整除。每个人可以给他左右相邻的人一些金币，最终使得
每个人的金币数目相等。你的任务是求出被转手的金币数量的最小值。比如，n=4，且4个人的金币数量分别为
1,2,5,4时，只需转移4枚金币（第3个人给第2个人两枚金币，第2个人和第4个人分别给第1个人1枚金币）即可实现
每人手中的金币数目相等。
## 输入格式
输入包含多组数据。每组数据第一行为整数n（n≤1 000 000），以下n行每行为一个整数，按逆时针顺序给出每个人
拥有的金币数。输入结束标志为文件结束符（EOF）。
##输出格式
对于每组数据，输出被转手金币数量的最小值。输入保证这个值在64位无符号整数范围内。
## 样例输入
```
3
100
100
100
4
1
2
5
4
```
## 样例输出
```
0
4
```
## 分析
二号给一号金币数为x2，三号给二号金币数为x3，M为每个人最后金币数，A1，A2等为初始金币数,C1为A1-M.
```
M = A1-X1+X2 => X2 = X1-C1
M = A2-X2+X3 => X3 = X1-C1-C2
M = A3-X3+X4 => X4 = X1-C1-C2-C3
```
所以求 |X1| + |X2| + |X3| + ... + |Xn| 最小
```
|X1| + |X1-C1| + |X1-C1-C2| + ... + |X1-C1-C2-...-Cn|
//实则可以转换为线段上X1到个点距离最短
//当X1在最中间时为最短
```